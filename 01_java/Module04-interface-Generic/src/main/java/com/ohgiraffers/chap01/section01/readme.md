# [심화] 추상 클래스 vs. 인터페이스

추상 클래스와 인터페이스는 모두 '추상화'를 위해 사용되지만, 목적과 쓰임새에 명확한 차이가 있습니다. 언제 무엇을 사용해야 할까요?

### 🚀 추상 클래스와 인터페이스 비교

| 구분                | 추상 클래스 (Abstract Class)                             | 인터페이스 (Interface)                                               |
| :------------------ |:----------------------------------------------------|:----------------------------------------------------------------|
| **핵심 목적** | **"is-a" 관계**: **관련성 높은 클래스들의 공통된 속성과 기능**을 추출      | **"can-do" 관계**: **특정 역할(기능)을 수행할 수 있다는 계약**을 정의                |
| **상속/구현** | `extends` 키워드 사용, **단일 상속**만 가능                     | `implements` 키워드 사용, **다중 구현** 가능                               |
| **멤버 구성** | 추상 메서드, 일반 메서드, 생성자, 멤버 변수 모두 포함 가능                 | 추상 메서드, `default` 메서드, `static` 메서드, 상수 필드만 가능                  |
| **사용 의도** | "같은 종류"의 객체들을 묶고 싶을 때 (예: `Animal`과 `Dog`)          | "역할"을 부여하고 싶을 때 (예: `Flyable`, `Runnable`)                      |
| **결합도** | 비교적 강한 결합 (부모-자식 관계)                                | 매우 느슨한 결합 (구현체-역할 관계)                                           |
| **언제 사용해야 하나?** | - 공통된 상태(필드)를 공유해야 할 때<br>- 기능의 일부를 미리 구현해두고 싶을 때   | - 완전히 다른 종류의 클래스들에게 동일한 기능(역할)을 부여하고 싶을 때<br>- 다중 상속의 이점이 필요할 때 |

**핵심 요약**: 상속 계층도에서 "같은 부류로 묶을 수 있는가?"를 고민한다면 **추상 클래스**를, "이 객체가 이 행동을 할 수 있는가?"를 고민한다면 **인터페이스**를 사용하는 것이 올바른 설계 방향입니다.

## 추상 클래스 예시: "is-a" 관계 (상속)
추상 클래스는 "~은 ~이다 (is-a)" 와 같이, 본질적으로 같은 종류의 객체들을 묶을 때 사용한다. 이는 정체성에 관한 관계이다.

핵심 개념: Dog is an Animal (개는 동물이다)

개(Dog)와 고양이(Cat)는 서로 다른 종이지만, 둘 다 '동물'(Animal)이라는 더 큰 분류에 속한다. 즉, 개는 동물의 한 종류이다. 이처럼 공통된 정체성을 공유할 때, 공통 속성(필드)과 기능(메서드)을 추출하여 추상 클래스로 만들 수 있다.
```java
// '동물'이라는 공통된 정체성과 속성, 기능을 정의한다.
abstract class Animal {
    String name; // 모든 동물은 이름을 가질 수 있다 (공통 필드)

    // 모든 동물은 숨을 쉰다 (공통 기능)
    void breathe() {
        System.out.println("숨을 쉽니다.");
    }

    // 울음소리는 동물마다 다르므로, 자식이 반드시 구현하도록 강제한다.
    abstract void makeSound();
}

// '개'는 '동물'이다. Animal 클래스를 상속받아 동물의 모든 특징을 물려받는다.
class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("멍멍!");
    }
}

// '고양이'는 '동물'이다.
class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("야옹~");
    }
}
```


## 인터페이스 예시: "can-do" 관계 (구현)
인터페이스는 "~을 할 수 있다 (can-do)" 와 같이, 종류는 전혀 다르지만 특정 행동을 동일하게 수행할 수 있는 객체들에게 '역할'을 부여할 때 사용한다.

핵심 개념: A Bird can fly, and a Drone can fly (새는 날 수 있고, 드론도 날 수 있다)

새(Bird)는 동물이지만 드론(Drone)은 기계이다. 둘은 본질적으로 전혀 다른 존재이며 공통점으로 묶을 수 없다. 하지만 '날 수 있다'(Flyable)는 행동(역할)을 똑같이 수행할 수 있다. 이처럼 특정 '기능'이나 '역할'을 클래스에 부여하고 싶을 때 인터페이스를 사용한다.
```java
// '날 수 있음'이라는 역할(행동)을 정의하는 계약서이다.
interface Flyable {
    void fly(); // 이 인터페이스를 구현하는 클래스는 반드시 fly() 메서드를 가져야 한다.
}

// '새'는 동물(Animal)의 한 종류이며, 동시에 '날 수 있는' 역할(Flyable)도 수행한다.
class Bird extends Animal implements Flyable {
    @Override
    public void fly() {
        System.out.println("새가 날개로 하늘을 납니다.");
    }
    
    @Override
    void makeSound() {
        System.out.println("짹짹");
    }
}

// '드론'은 기계이며, '날 수 있는' 역할(Flyable)을 수행한다.
class Drone implements Flyable {
    @Override
    public void fly() {
        System.out.println("드론이 프로펠러를 돌려 비행합니다.");
    }
}