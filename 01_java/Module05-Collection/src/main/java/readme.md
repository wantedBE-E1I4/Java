# 컬렉션

# 📌 1. 컬렉션 프레임워크(Collection Framework)란?

## 🔹 컬렉션이란?

- 객체들을 효율적으로 저장하고 관리하기 위한 자료구조의 집합
- 배열보다 유연하며, 다양한 데이터 구조(List, Set, Queue, Map 등)를 제공
- 컬렉션 프레임워크는 모든 자료구조를 인터페이스 기반으로 제공하여, 일관된 방식으로 데이터를 다룰 수 있도록 설계됨.

## 📌 2. 컬렉션 프레임워크의 인터페이스 기반 설계

- 🔹 왜 인터페이스를 사용하는가?
- "동일한 인터페이스를 통해 다양한 구현체를 유연하게 사용할 수 있도록 한다."
- 즉, 인터페이스가 메서드(기능)를 정의하고, 구현체가 이를 구현하면서 각 자료구조의 특성을 반영함.
- 이는 인터페이스 새로운 자료구조를 추가할 때 기존 코드를 수정하지 않고도 새로운 구현체를 추가 할 수 있기 때문이다.

```
Collection (인터페이스)
│
├── List (인터페이스)
│   ├── ArrayList (구현 클래스)  → 동적 배열 기반
│   ├── LinkedList (구현 클래스) → 이중 연결 리스트 기반
│   ├── Vector (구현 클래스)     → 동기화된 동적 배열 기반
│
├── Set (인터페이스)
│   ├── HashSet (구현 클래스)    → 해시 테이블 기반 (중복X)
│   ├── TreeSet (구현 클래스)    → 정렬된 이진 탐색 트리 기반
│   ├── LinkedHashSet (구현 클래스) → 해시 테이블 + 연결 리스트 기반
│
└── Map (인터페이스)  (컬렉션이 아니지만 포함됨)
    ├── HashMap (구현 클래스)     → 해시 테이블 기반 (키-값 저장)
    ├── LinkedHashMap (구현 클래스) → 해시 테이블 + 연결 리스트 기반
    ├── TreeMap (구현 클래스)     → 정렬된 이진 탐색 트리 기반

```

- List는 사이즈를 동적으로 늘렸다 줄일 수 있다.
- 여러가지 기능의 중심 (등록, 삭제, 조회)
- List는 밑에 다음번째 주소를 저장한다.
- 2번으로 가고싶으면 1번부터 다시 들른다. 비효율적이다.

## 📌 3. List, Set, Map의 주요 자료구조 및 해시 테이블 분석

### 🔹 1) ArrayList & LinkedList (List 인터페이스)

### ✅ ArrayList (동적 배열 기반)

- 내부적으로 배열을 사용하여 데이터를 저장하며, 크기가 자동으로 조정됨.
- 랜덤 접근(인덱스 기반 조회) 속도가 빠름 O(1)
- 중간 삽입/삭제가 느림 O(n), 배열을 재배열해야 함. (고정형에 유리)

```
ArrayList
[0] → [1] → [2] → [3] → [4] → [5] → [6] → [7] → [null]
(각 인덱스에 객체 저장, 크기 초과 시 새로운 배열을 생성하여 복사)
```

### ✅ LinkedList (이중 연결 리스트 기반)

- 각 요소(Node)가 이전 및 다음 요소를 가리키는 포인터를 가짐
- **삽입/삭제** 속도가 빠름 **O(1)**, 연결만 변경하면 됨.
- 랜덤 접근(인덱스 조회) 속도가 느림 O(n), 처음부터 탐색해야 함. (가변형에 유리)

```
Head → [Node1] ↔ [Node2] ↔ [Node3] ↔ [Node4] → Tail
       (각 노드는 **이전과 다음**을 가리키는 포인터를 가짐)
```

---

### 🔹 2) HashSet & TreeSet (Set 인터페이스)

### ✅ HashSet (해시 테이블 기반)

- 해시 테이블을 이용하여 **중복을 허용**하지 않음 (회원가입 전화번호)
- 해시 함수를 이용하여 요소를 빠르게 검색 가능 (O(1))
    - 해시 함수로 같은 값이 나오는지 찾기(값을 저장할때부터 비교함 )
- 내부적으로 배열 + 해시 함수 + 버킷 구조를 사용하여 데이터를 저장
  🔍 HashSet 내부 구조 다이어그램

```
HashSet
Bucket 0 → [객체 A]
Bucket 1 → [객체 B]
Bucket 2 → [객체 C] → [객체 D] (해시 충돌 시 체이닝 방식 사용)
(하나의 엔트리에 2개의 객체를 저장하고 내부에서 다음 객체를 지정하는 방식)

```

### ✅ TreeSet (정렬된 이진 탐색 트리 기반) -반씩 줄며 값이 있어 없어?! 비교

- 이진 탐색 트리(Red-Black Tree)를 기반으로 정렬된 상태로 저장
- 삽입/삭제/검색 모두 O(log n)의 성능을 가짐
- 데이터를 정렬된 상태로 유지해야 할 때 사용
  🔍 TreeSet 내부 구조 다이어그램

```
       [50]
      /    \\
    [30]   [70]
   /   \\   /   \\
[20] [40] [60] [80]

```

---

### 🔹 3) HashMap (해시 테이블 기반, 키-값 저장)

### ✅ HashMap (버킷 배열 + 체이닝 구조)

- 키(key)를 해시 함수로 변환하여 인덱스(bucket)에 저장
- 해시 충돌이 발생하면 체이닝(Linked List) 또는 오픈 어드레싱 방식 사용
- 검색 속도: O(1), 해시 충돌 시 O(n)
  🔍 HashMap 내부 구조 다이어그램

```
HashMap
Bucket 0 → [Key1, Value1]
Bucket 1 → [Key2, Value2] → [Key3, Value3] (체이닝으로 연결)
Bucket 2 → [Key4, Value4]

```

---

## 📌 4. 인터페이스를 사용하는 이유

### 🔹 1) 유연한 설계 및 코드 확장성

- 컬렉션 프레임워크에서 List, Set, Map 등은 인터페이스로 제공되며,
- 구현체를 선택하여 사용할 수 있도록 설계됨.
- 구현체를 바꾸어도 코드 수정 없이 다른 자료구조를 사용할 수 있음.

📌 예제: List 인터페이스를 활용한 코드 확장성

```java
List<String> list = new ArrayList<>();
list.add("Hello");
list.add("World");

// 필요에 따라 구현체를 변경해도 코드 수정 없이 사용 가능
list = new LinkedList<>(); // 동적으로 구현체 변경 가능

```

---

## 📌 5. 컬렉션 순회 표준: Iterator

`Iterator`(반복자)는 컬렉션 프레임워크에 저장된 요소를 순차적으로 접근하기 위한 표준 인터페이스입니다. `for-each` 구문은 내부적으로 `Iterator`를 사용하여 동작합니다.

- **주요 메서드**:
    - `boolean hasNext()`: 다음에 가져올 요소가 있으면 `true`를 반환합니다.
    - `E next()`: 다음 요소를 반환합니다.
    - `void remove()`: `next()`로 반환된 마지막 요소를 컬렉션에서 제거합니다. (선택적 기능)

**💡 왜 사용하는가?**`Iterator`를 사용하면 컬렉션의 구현 방식(ArrayList, LinkedList 등)에 상관없이 동일한 코드로 요소를 순회할 수 있습니다. 또한, 컬렉션을 순회하는 도중에 안전하게 요소를 제거할 수 있는 유일한 표준 방법입니다.

**Map이 뭐냐면**

**key** - 중복허용X(주민번호) / **value** -중복허용O(이름)

- key로 찾고 value를 부른다.
- hashMap, LinkedMap# 컬렉션

# 📌 1. 컬렉션 프레임워크(Collection Framework)란?

## 🔹 컬렉션이란?

- 객체들을 효율적으로 저장하고 관리하기 위한 자료구조의 집합
- 배열보다 유연하며, 다양한 데이터 구조(List, Set, Queue, Map 등)를 제공
- 컬렉션 프레임워크는 모든 자료구조를 인터페이스 기반으로 제공하여, 일관된 방식으로 데이터를 다룰 수 있도록 설계됨.

## 📌 2. 컬렉션 프레임워크의 인터페이스 기반 설계

- 🔹 왜 인터페이스를 사용하는가?
- "동일한 인터페이스를 통해 다양한 구현체를 유연하게 사용할 수 있도록 한다."
- 즉, 인터페이스가 메서드(기능)를 정의하고, 구현체가 이를 구현하면서 각 자료구조의 특성을 반영함.
- 이는 인터페이스 새로운 자료구조를 추가할 때 기존 코드를 수정하지 않고도 새로운 구현체를 추가 할 수 있기 때문이다.

```
Collection (인터페이스)
│
├── List (인터페이스)
│   ├── ArrayList (구현 클래스)  → 동적 배열 기반
│   ├── LinkedList (구현 클래스) → 이중 연결 리스트 기반
│   ├── Vector (구현 클래스)     → 동기화된 동적 배열 기반
│
├── Set (인터페이스)
│   ├── HashSet (구현 클래스)    → 해시 테이블 기반 (중복X)
│   ├── TreeSet (구현 클래스)    → 정렬된 이진 탐색 트리 기반
│   ├── LinkedHashSet (구현 클래스) → 해시 테이블 + 연결 리스트 기반
│
└── Map (인터페이스)  (컬렉션이 아니지만 포함됨)
    ├── HashMap (구현 클래스)     → 해시 테이블 기반 (키-값 저장)
    ├── LinkedHashMap (구현 클래스) → 해시 테이블 + 연결 리스트 기반
    ├── TreeMap (구현 클래스)     → 정렬된 이진 탐색 트리 기반

```

- List는 사이즈를 동적으로 늘렸다 줄일 수 있다.
- 여러가지 기능의 중심 (등록, 삭제, 조회)
- List는 밑에 다음번째 주소를 저장한다.
- 2번으로 가고싶으면 1번부터 다시 들른다. 비효율적이다.

## 📌 3. List, Set, Map의 주요 자료구조 및 해시 테이블 분석

### 🔹 1) ArrayList & LinkedList (List 인터페이스)

### ✅ ArrayList (동적 배열 기반)

- 내부적으로 배열을 사용하여 데이터를 저장하며, 크기가 자동으로 조정됨.
- 랜덤 접근(인덱스 기반 조회) 속도가 빠름 O(1)
- 중간 삽입/삭제가 느림 O(n), 배열을 재배열해야 함. (고정형에 유리)

```
ArrayList
[0] → [1] → [2] → [3] → [4] → [5] → [6] → [7] → [null]
(각 인덱스에 객체 저장, 크기 초과 시 새로운 배열을 생성하여 복사)
```

### ✅ LinkedList (이중 연결 리스트 기반)

- 각 요소(Node)가 이전 및 다음 요소를 가리키는 포인터를 가짐
- **삽입/삭제** 속도가 빠름 **O(1)**, 연결만 변경하면 됨.
- 랜덤 접근(인덱스 조회) 속도가 느림 O(n), 처음부터 탐색해야 함. (가변형에 유리)

```
Head → [Node1] ↔ [Node2] ↔ [Node3] ↔ [Node4] → Tail
       (각 노드는 **이전과 다음**을 가리키는 포인터를 가짐)
```

---

### 🔹 2) HashSet & TreeSet (Set 인터페이스)

### ✅ HashSet (해시 테이블 기반)

- 해시 테이블을 이용하여 **중복을 허용**하지 않음 (회원가입 전화번호)
- 해시 함수를 이용하여 요소를 빠르게 검색 가능 (O(1))
    - 해시 함수로 같은 값이 나오는지 찾기(값을 저장할때부터 비교함 )
- 내부적으로 배열 + 해시 함수 + 버킷 구조를 사용하여 데이터를 저장
  🔍 HashSet 내부 구조 다이어그램

```
HashSet
Bucket 0 → [객체 A]
Bucket 1 → [객체 B]
Bucket 2 → [객체 C] → [객체 D] (해시 충돌 시 체이닝 방식 사용)
(하나의 엔트리에 2개의 객체를 저장하고 내부에서 다음 객체를 지정하는 방식)

```

### ✅ TreeSet (정렬된 이진 탐색 트리 기반) -반씩 줄며 값이 있어 없어?! 비교

- 이진 탐색 트리(Red-Black Tree)를 기반으로 정렬된 상태로 저장
- 삽입/삭제/검색 모두 O(log n)의 성능을 가짐
- 데이터를 정렬된 상태로 유지해야 할 때 사용
  🔍 TreeSet 내부 구조 다이어그램

```
       [50]
      /    \\
    [30]   [70]
   /   \\   /   \\
[20] [40] [60] [80]

```

---

### 🔹 3) HashMap (해시 테이블 기반, 키-값 저장)

### ✅ HashMap (버킷 배열 + 체이닝 구조)

- 키(key)를 해시 함수로 변환하여 인덱스(bucket)에 저장
- 해시 충돌이 발생하면 체이닝(Linked List) 또는 오픈 어드레싱 방식 사용
- 검색 속도: O(1), 해시 충돌 시 O(n)
  🔍 HashMap 내부 구조 다이어그램

```
HashMap
Bucket 0 → [Key1, Value1]
Bucket 1 → [Key2, Value2] → [Key3, Value3] (체이닝으로 연결)
Bucket 2 → [Key4, Value4]

```

---

## 📌 4. 인터페이스를 사용하는 이유

### 🔹 1) 유연한 설계 및 코드 확장성

- 컬렉션 프레임워크에서 List, Set, Map 등은 인터페이스로 제공되며,
- 구현체를 선택하여 사용할 수 있도록 설계됨.
- 구현체를 바꾸어도 코드 수정 없이 다른 자료구조를 사용할 수 있음.

📌 예제: List 인터페이스를 활용한 코드 확장성

```java
List<String> list = new ArrayList<>();
list.add("Hello");
list.add("World");

// 필요에 따라 구현체를 변경해도 코드 수정 없이 사용 가능
list = new LinkedList<>(); // 동적으로 구현체 변경 가능

```

---

## 📌 5. 컬렉션 순회 표준: Iterator

`Iterator`(반복자)는 컬렉션 프레임워크에 저장된 요소를 순차적으로 접근하기 위한 표준 인터페이스입니다. `for-each` 구문은 내부적으로 `Iterator`를 사용하여 동작합니다.

- **주요 메서드**:
    - `boolean hasNext()`: 다음에 가져올 요소가 있으면 `true`를 반환합니다.
    - `E next()`: 다음 요소를 반환합니다.
    - `void remove()`: `next()`로 반환된 마지막 요소를 컬렉션에서 제거합니다. (선택적 기능)

**💡 왜 사용하는가?**`Iterator`를 사용하면 컬렉션의 구현 방식(ArrayList, LinkedList 등)에 상관없이 동일한 코드로 요소를 순회할 수 있습니다. 또한, 컬렉션을 순회하는 도중에 안전하게 요소를 제거할 수 있는 유일한 표준 방법입니다.

**Map이 뭐냐면**

**key** - 중복허용X(주민번호) / **value** -중복허용O(이름)

- key로 찾고 value를 부른다.
- hashMap, LinkedMap